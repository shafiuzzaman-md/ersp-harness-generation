[
    {
        "role": "user",
        "content": "Corrected Prompt Template (Use This)\n\n### 1. YOUR TASK (STRICT) For every .c file provided in the user message (e.g., source_A.c, source_B.c), you MUST generate two new C files:\n\n    An Instrumented File (e.g., instrumented_source_A.c):\n\n        This is a copy of the original C file.\n\n        Remove all I/O functions (e.g., printf, fgets).\n\n        Replace all input sources with calls to an external symbolic source function (e.g., extern int __klee_source();).\n\n        DO NOT include <klee/klee.h> in this file.\n\n    A Driver File (e.g., driver_source_A.c):\n\n        You MUST include <klee/klee.h>. (My Python script will remove this later).\n\n        This file defines the main() function.\n\n        It defines the __klee_source() function(s) using klee_make_symbolic.\n\n        It declares the instrumented function as extern (e.g., extern void CWE123_..._bad(void);).\n\n        It calls the instrumented function in main.\n\nYou will also generate one build.sh and one run_klee.sh script.\n\n### 2. BUILD & KLEE INSTRUCTIONS (STRICT)\n\n    CWD Assumption: All scripts MUST assume they are run from inside their parent directory (e.g., ./cwes/cwe124/output/generated/).\n\n    build.sh:\n\n        Must begin with set -e.\n\n        For each pair of files, you must compile both C files into intermediate bitcode (.o) files.\n\n        Then, you MUST use llvm-link to link the pair of .o files into a single, final .bc file.\n\n        Example for one pair:\n        Bash\n\n        clang -emit-llvm -c driver_file1.c -o driver_file1.o\n        clang -emit-llvm -c instrumented_file1.c -o instrumented_file1.o\n        llvm-link driver_file1.o instrumented_file1.o -o final_file1.bc\n\n    run_klee.sh:\n\n        Must begin with set -e.\n\n        Must run KLEE on each final, linked .bc file (e.g., final_file1.bc).\n\n        KLEE Flags: Use the flags: --posix-runtime -libc=uclibc.\n\n        KLEE Output: After each KLEE run, rename klee-last (e.g., mv klee-last final_file1_klee).\n\n### 3. OUTPUT FORMAT (ABSOLUTELY STRICT)\n\n    DO NOT respond with any text, explanations, or titles.\n\n    Your entire response MUST start with a file path.\n\n    Your entire response MUST end with the \u2736 delimiter.\n\n    Every file path MUST be followed by a \u2736 delimiter.\n\n    Every file content block MUST be followed by a \u2736 delimiter.\n\n    File Paths: All generated files MUST be placed in the directory ./cwes/cwexxx/output/generated/, where cwexxx is the lowercase CWE number (e.g., cwe124).\n\nEXAMPLE OF THE ONLY VALID RESPONSE FORMAT:\n\n./cwes/cwe124/output/generated/instrumented_file1.c\u2736\n// instrumented_file1.c\n// NO klee.h include here\nextern int __klee_source(void);\nextern void CWE123_..._bad(void);\n// ...\n\u2736\n./cwes/cwe124/output/generated/driver_file1.c\u2736\n// driver_file1.c\n#include <klee/klee.h> // Include is OK here\n// ...\nint __klee_source(void) {\n  int x;\n  klee_make_symbolic(&x, sizeof(x), \"x\");\n  return x;\n}\nint main(void) {\n  CWE123_..._bad();\n  return 0;\n}\n\u2736\n./cwes/cwe124/output/generated/build.sh\u2736\n#!/bin/bash\nset -e\nclang -emit-llvm -c driver_file1.c -o driver_file1.o\nclang -emit-llvm -c instrumented_file1.c -o instrumented_file1.o\nllvm-link driver_file1.o instrumented_file1.o -o final_file1.bc\n# (repeat for file2, file3, etc.)\n\u2736\n./cwes/cwe124/output/generated/run_klee.sh\u2736\n#!/bin/bash\nset -e\nklee --posix-runtime -libc=uclibc final_file1.bc\nmv klee-last final_file1_klee\n# (repeat for file2, file3, etc.)\n\u2736\n\n--- START OF CODE ---\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/example/driver.c\n// driver.c\n#include \"klee/klee.h\"\n\n// Provide the symbolic source used by the instrumented bad function\nint __klee_source(void) {\n    int data;\n    klee_make_symbolic(&data, sizeof(data), \"data\");\n    // Optional bounds to speed up search; remove if you want unbounded\n    klee_assume(data >= -100 && data <= 100);\n    return data;\n}\n\n// Declaration of the instrumented Juliet bad function (same name)\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad(void);\n\nint main(void) {\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad();\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/example/driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n// driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n#include \"klee/klee.h\"\n\n/* Provide the symbolic source used by the instrumented bad function */\nint __klee_source(void) {\n    int data;\n    klee_make_symbolic(&data, sizeof(data), \"data\");\n    return data;\n}\n\n/* Pull in the instrumented implementation (same directory or adjust the path) */\n#include \"instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\"\n\n/* Exact Juliet function name is preserved in the included file */\nint main(void) {\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad();\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/example/instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n// instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n#include <stddef.h>\n\nint __klee_source(void);  // defined by the driver\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad(void) {\n    int data = __klee_source();     // model the socket-provided int\n\n    int i;\n    int buffer[10] = {0};\n\n    // Bad sink: checks only lower bound; missing upper bound check\n    if (data >= 0) {\n        buffer[data] = 1;           // KLEE will flag OOB when data >= 10\n        for (i = 0; i < 10; i++) {\n            (void)buffer[i];        // keep side effects\n        }\n    }\n}\n\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/example/README.md\n# KLEE Harness\nWe divide harness generation into two parts:\n- Driver: makes inputs symbolic and calls the target entrypoint.\n- Instrumented file: preserves the exact vulnerable function but replaces real I/O with a stubbed source; focuses only on the sink (hotspot) logic. \n\nIn this example:\n- The driver defines __klee_source() via klee_make_symbolic, then #includes the instrumented file and calls the original function name (our symbolic-execution entrypoint).\n- The instrumented file targets just the sink logic, stubbing out non-interesting parts so exploration is small and fast.\n\n\n## Build and run\n### Compile just the driver (it includes the instrumented file)\nclang -emit-llvm -c -g -O0 \\\n      driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c \\\n      -o harness.bc\n\n### Run KLEE\nklee harness.bc\n\n\n## Example KLEE output\n\nKLEE: ERROR: ./instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c:14: memory error: out of bound pointer\nKLEE: NOTE: now ignoring this error at this location\n\nKLEE: done: total instructions = 657\nKLEE: done: completed paths = 2\nKLEE: done: partially completed paths = 1\nKLEE: done: generated tests = 3\n\nThis means: KLEE found a concrete input that drives the program to an out-of-bounds write at the sink line in the instrumented file. It explored a few paths and produced concrete test cases.\n\n## Inspecting the failing test case \nKLEE writes .ktest files under klee-last/. Use ktest-tool to view inputs:\n    ktest-tool klee-last/test000002.ktest\n\nobject 0: name: 'data'\nobject 0: size: 4\nobject 0: data: b'\\n\\x00\\x00\\x00'\nobject 0: hex : 0x0a000000\nobject 0: int : 10\nobject 0: uint: 10\nobject 0: text: ....\n\nThat shows the symbolic variable data is 10 (0x0a), which triggers the OOB write.\n\nYou\u2019ll see a .kquery describing the constraints:\n\narray data[4] : w32 -> w8 = symbolic\n(query [(Sle 0\n              N0:(ReadLSB w32 0 data))\n         (Eq false\n             (Ult (Mul w64 4 (SExt w64 N0))\n                  37))]\n        false)\n\nInterpretation:\n- data is a 32-bit symbolic input\n- Constraints include data >= 0 (Sle 0 N0) and a condition ensuring the write goes out of bounds\n- Solver returns a model (e.g., data = 10) satisfying these\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/complexexample/readme.md\n## Example build & run\n\nclang -emit-llvm -c complex_data_structure_symbolic_driver.c -g -o complex_data_structure_symbolic_driver.bc\n\nklee complex_data_structure_symbolic_driver.bc\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/complexexample/complex_data_structure_symbolic_driver.c\n#include \"klee/klee.h\"\n#include \"instrumented_complex_data_structure.c\"\n\nint main(void) {\n    RequestFrame frame;\n\n    /* Step 1: create separate symbolic variables */\n    int sym_index;\n    int sym_length;\n    int sym_buffer[10];\n\n    klee_make_symbolic(&sym_index,  sizeof(sym_index),  \"index\");\n    klee_make_symbolic(&sym_length, sizeof(sym_length), \"length\");\n    klee_make_symbolic(sym_buffer,  sizeof(sym_buffer), \"buffer\");\n\n    /* Step 2: bind symbolic vars into the struct */\n    frame.index  = sym_index;\n    frame.length = sym_length;\n    for (int i = 0; i < 10; ++i) {\n        frame.buffer[i] = sym_buffer[i];\n    }\n\n    /* Step 3: bind struct to a pointer and call the sink */\n    RequestFrame *frame_ptr = &frame;\n    complex_data_structure_sink(frame_ptr);\n\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/examples/complexexample/instrumented_complex_data_structure.c\n#include \"klee/klee.h\"\n\ntypedef struct {\n    int index;   \n    int length;  \n    int buffer[10];\n} RequestFrame;\n\nvoid complex_data_structure_sink(RequestFrame *frame) {\n    if (!frame) {\n        return;\n    }\n\n    int idx = frame->index;\n\n    int value = frame->buffer[idx];   //potential OOB read\n\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/targets/CWE124_Buffer_Underwrite__char_alloca_ncpy_03.c\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE124_Buffer_Underwrite__char_alloca_ncpy_03.c\nLabel Definition File: CWE124_Buffer_Underwrite.stack.label.xml\nTemplate File: sources-sink-03.tmpl.c\n*/\n/*\n * @description\n * CWE: 124 Buffer Underwrite\n * BadSource:  Set data pointer to before the allocated memory buffer\n * GoodSource: Set data pointer to the allocated memory buffer\n * Sink: ncpy\n *    BadSink : Copy string to data using strncpy\n * Flow Variant: 03 Control flow: if(5==5) and if(5!=5)\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifndef OMITBAD\n\nvoid CWE124_Buffer_Underwrite__char_alloca_ncpy_03_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(5==5)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the 5==5 to 5!=5 */\nstatic void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set data pointer to the allocated memory buffer */\n        data = dataBuffer;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(5==5)\n    {\n        /* FIX: Set data pointer to the allocated memory buffer */\n        data = dataBuffer;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n    }\n}\n\nvoid CWE124_Buffer_Underwrite__char_alloca_ncpy_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE124_Buffer_Underwrite__char_alloca_ncpy_03_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE124_Buffer_Underwrite__char_alloca_ncpy_03_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe124/targets/CWE124_Buffer_Underwrite__char_alloca_cpy_01.c\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE124_Buffer_Underwrite__char_alloca_cpy_01.c\nLabel Definition File: CWE124_Buffer_Underwrite.stack.label.xml\nTemplate File: sources-sink-01.tmpl.c\n*/\n/*\n * @description\n * CWE: 124 Buffer Underwrite\n * BadSource:  Set data pointer to before the allocated memory buffer\n * GoodSource: Set data pointer to the allocated memory buffer\n * Sink: cpy\n *    BadSink : Copy string to data using strcpy\n * Flow Variant: 01 Baseline\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifndef OMITBAD\n\nvoid CWE124_Buffer_Underwrite__char_alloca_cpy_01_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FIX: Set data pointer to the allocated memory buffer */\n    data = dataBuffer;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n\nvoid CWE124_Buffer_Underwrite__char_alloca_cpy_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE124_Buffer_Underwrite__char_alloca_cpy_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE124_Buffer_Underwrite__char_alloca_cpy_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n\n\n\n--- END OF CODE ---"
    }
]