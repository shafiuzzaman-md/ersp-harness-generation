[
    {
        "role": "user",
        "content": "Corrected Prompt Template (Use This)\n\n### 1. YOUR TASK (STRICT) For every .c file provided in the user message (e.g., source_A.c, source_B.c), you MUST generate two new C files:\n\n    An Instrumented File (e.g., instrumented_source_A.c):\n\n        This is a copy of the original C file.\n\n        Remove all I/O functions (e.g., printf, fgets).\n\n        Replace all input sources with calls to an external symbolic source function (e.g., extern int __klee_source();).\n\n        DO NOT include <klee/klee.h> in this file.\n\n    A Driver File (e.g., driver_source_A.c):\n\n        You MUST include <klee/klee.h>. (My Python script will remove this later).\n\n        This file defines the main() function.\n\n        It defines the __klee_source() function(s) using klee_make_symbolic.\n\n        It declares the instrumented function as extern (e.g., extern void CWE123_..._bad(void);).\n\n        It calls the instrumented function in main.\n\nYou will also generate one build.sh and one run_klee.sh script.\n\n### 2. BUILD & KLEE INSTRUCTIONS (STRICT)\n\n    CWD Assumption: All scripts MUST assume they are run from inside their parent directory (e.g., ./cwes/cwe124/output/generated/).\n\n    build.sh:\n\n        Must begin with set -e.\n\n        For each pair of files, you must compile both C files into intermediate bitcode (.o) files.\n\n        Then, you MUST use llvm-link to link the pair of .o files into a single, final .bc file.\n\n        Example for one pair:\n        Bash\n\n        clang -emit-llvm -c driver_file1.c -o driver_file1.o\n        clang -emit-llvm -c instrumented_file1.c -o instrumented_file1.o\n        llvm-link driver_file1.o instrumented_file1.o -o final_file1.bc\n\n    run_klee.sh:\n\n        Must begin with set -e.\n\n        Must run KLEE on each final, linked .bc file (e.g., final_file1.bc).\n\n        KLEE Flags: Use the flags: --posix-runtime -libc=uclibc.\n\n        KLEE Output: After each KLEE run, rename klee-last (e.g., mv klee-last final_file1_klee).\n\n### 3. OUTPUT FORMAT (ABSOLUTELY STRICT)\n\n    DO NOT respond with any text, explanations, or titles.\n\n    Your entire response MUST start with a file path.\n\n    Your entire response MUST end with the \u2736 delimiter.\n\n    Every file path MUST be followed by a \u2736 delimiter.\n\n    Every file content block MUST be followed by a \u2736 delimiter.\n\n    File Paths: All generated files MUST be placed in the directory ./cwes/cwexxx/output/generated/, where cwexxx is the lowercase CWE number (e.g., cwe124).\n\nEXAMPLE OF THE ONLY VALID RESPONSE FORMAT:\n\n./cwes/cwe124/output/generated/instrumented_file1.c\u2736\n// instrumented_file1.c\n// NO klee.h include here\nextern int __klee_source(void);\nextern void CWE123_..._bad(void);\n// ...\n\u2736\n./cwes/cwe124/output/generated/driver_file1.c\u2736\n// driver_file1.c\n#include <klee/klee.h> // Include is OK here\n// ...\nint __klee_source(void) {\n  int x;\n  klee_make_symbolic(&x, sizeof(x), \"x\");\n  return x;\n}\nint main(void) {\n  CWE123_..._bad();\n  return 0;\n}\n\u2736\n./cwes/cwe124/output/generated/build.sh\u2736\n#!/bin/bash\nset -e\nclang -emit-llvm -c driver_file1.c -o driver_file1.o\nclang -emit-llvm -c instrumented_file1.c -o instrumented_file1.o\nllvm-link driver_file1.o instrumented_file1.o -o final_file1.bc\n# (repeat for file2, file3, etc.)\n\u2736\n./cwes/cwe124/output/generated/run_klee.sh\u2736\n#!/bin/bash\nset -e\nklee --posix-runtime -libc=uclibc final_file1.bc\nmv klee-last final_file1_klee\n# (repeat for file2, file3, etc.)\n\u2736\n\n--- START OF CODE ---\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/example/driver.c\n// driver.c\n#include \"klee/klee.h\"\n\n// Provide the symbolic source used by the instrumented bad function\nint __klee_source(void) {\n    int data;\n    klee_make_symbolic(&data, sizeof(data), \"data\");\n    // Optional bounds to speed up search; remove if you want unbounded\n    klee_assume(data >= -100 && data <= 100);\n    return data;\n}\n\n// Declaration of the instrumented Juliet bad function (same name)\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad(void);\n\nint main(void) {\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad();\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/example/driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n// driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n#include \"klee/klee.h\"\n\n/* Provide the symbolic source used by the instrumented bad function */\nint __klee_source(void) {\n    int data;\n    klee_make_symbolic(&data, sizeof(data), \"data\");\n    return data;\n}\n\n/* Pull in the instrumented implementation (same directory or adjust the path) */\n#include \"instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\"\n\n/* Exact Juliet function name is preserved in the included file */\nint main(void) {\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad();\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/example/instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n// instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c\n#include <stddef.h>\n\nint __klee_source(void);  // defined by the driver\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad(void) {\n    int data = __klee_source();     // model the socket-provided int\n\n    int i;\n    int buffer[10] = {0};\n\n    // Bad sink: checks only lower bound; missing upper bound check\n    if (data >= 0) {\n        buffer[data] = 1;           // KLEE will flag OOB when data >= 10\n        for (i = 0; i < 10; i++) {\n            (void)buffer[i];        // keep side effects\n        }\n    }\n}\n\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/example/README.md\n# KLEE Harness\nWe divide harness generation into two parts:\n- Driver: makes inputs symbolic and calls the target entrypoint.\n- Instrumented file: preserves the exact vulnerable function but replaces real I/O with a stubbed source; focuses only on the sink (hotspot) logic. \n\nIn this example:\n- The driver defines __klee_source() via klee_make_symbolic, then #includes the instrumented file and calls the original function name (our symbolic-execution entrypoint).\n- The instrumented file targets just the sink logic, stubbing out non-interesting parts so exploration is small and fast.\n\n\n## Build and run\n### Compile just the driver (it includes the instrumented file)\nclang -emit-llvm -c -g -O0 \\\n      driver_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c \\\n      -o harness.bc\n\n### Run KLEE\nklee harness.bc\n\n\n## Example KLEE output\n\nKLEE: ERROR: ./instrumented_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_01_bad.c:14: memory error: out of bound pointer\nKLEE: NOTE: now ignoring this error at this location\n\nKLEE: done: total instructions = 657\nKLEE: done: completed paths = 2\nKLEE: done: partially completed paths = 1\nKLEE: done: generated tests = 3\n\nThis means: KLEE found a concrete input that drives the program to an out-of-bounds write at the sink line in the instrumented file. It explored a few paths and produced concrete test cases.\n\n## Inspecting the failing test case \nKLEE writes .ktest files under klee-last/. Use ktest-tool to view inputs:\n    ktest-tool klee-last/test000002.ktest\n\nobject 0: name: 'data'\nobject 0: size: 4\nobject 0: data: b'\\n\\x00\\x00\\x00'\nobject 0: hex : 0x0a000000\nobject 0: int : 10\nobject 0: uint: 10\nobject 0: text: ....\n\nThat shows the symbolic variable data is 10 (0x0a), which triggers the OOB write.\n\nYou\u2019ll see a .kquery describing the constraints:\n\narray data[4] : w32 -> w8 = symbolic\n(query [(Sle 0\n              N0:(ReadLSB w32 0 data))\n         (Eq false\n             (Ult (Mul w64 4 (SExt w64 N0))\n                  37))]\n        false)\n\nInterpretation:\n- data is a 32-bit symbolic input\n- Constraints include data >= 0 (Sle 0 N0) and a condition ensuring the write goes out of bounds\n- Solver returns a model (e.g., data = 10) satisfying these\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/complexexample/readme.md\n## Example build & run\n\nclang -emit-llvm -c complex_data_structure_symbolic_driver.c -g -o complex_data_structure_symbolic_driver.bc\n\nklee complex_data_structure_symbolic_driver.bc\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/complexexample/complex_data_structure_symbolic_driver.c\n#include \"klee/klee.h\"\n#include \"instrumented_complex_data_structure.c\"\n\nint main(void) {\n    RequestFrame frame;\n\n    /* Step 1: create separate symbolic variables */\n    int sym_index;\n    int sym_length;\n    int sym_buffer[10];\n\n    klee_make_symbolic(&sym_index,  sizeof(sym_index),  \"index\");\n    klee_make_symbolic(&sym_length, sizeof(sym_length), \"length\");\n    klee_make_symbolic(sym_buffer,  sizeof(sym_buffer), \"buffer\");\n\n    /* Step 2: bind symbolic vars into the struct */\n    frame.index  = sym_index;\n    frame.length = sym_length;\n    for (int i = 0; i < 10; ++i) {\n        frame.buffer[i] = sym_buffer[i];\n    }\n\n    /* Step 3: bind struct to a pointer and call the sink */\n    RequestFrame *frame_ptr = &frame;\n    complex_data_structure_sink(frame_ptr);\n\n    return 0;\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/examples/complexexample/instrumented_complex_data_structure.c\n#include \"klee/klee.h\"\n\ntypedef struct {\n    int index;   \n    int length;  \n    int buffer[10];\n} RequestFrame;\n\nvoid complex_data_structure_sink(RequestFrame *frame) {\n    if (!frame) {\n        return;\n    }\n\n    int idx = frame->index;\n\n    int value = frame->buffer[idx];   //potential OOB read\n\n}\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/targets/CWE123_Write_What_Where_Condition__fgets_03.c\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE123_Write_What_Where_Condition__fgets_03.c\nLabel Definition File: CWE123_Write_What_Where_Condition.label.xml\nTemplate File: sources-sink-03.tmpl.c\n*/\n/*\n * @description\n * CWE: 123 Write-What-Where Condition\n * BadSource: fgets Overwrite linked list pointers using fgets\n * GoodSource: Don't overwrite linked list pointers\n * Sink:\n *    BadSink : Remove element from list\n * Flow Variant: 03 Control flow: if(5==5) and if(5!=5)\n *\n * */\n\n#include \"std_testcase.h\"\n\ntypedef struct _linkedList\n{\n    struct _linkedList *next;\n    struct _linkedList *prev;\n} linkedList;\n\ntypedef struct _badStruct\n{\n    linkedList list;\n} badStruct;\n\nstatic linkedList *linkedListPrev, *linkedListNext;\n\n#ifndef OMITBAD\n\nvoid CWE123_Write_What_Where_Condition__fgets_03_bad()\n{\n    badStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    if(5==5)\n    {\n        /* FLAW: overwrite linked list pointers with user data */\n        if (fgets((char*)&data, sizeof(data), stdin) == NULL)\n        {\n            printLine(\"fgets failed!\");\n            exit(1);\n        }\n    }\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the 5==5 to 5!=5 */\nstatic void goodG2B1()\n{\n    badStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: don't overwrite linked list pointers */\n        ; /* empty statement needed by some flow variants */\n    }\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    badStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    if(5==5)\n    {\n        /* FIX: don't overwrite linked list pointers */\n        ; /* empty statement needed by some flow variants */\n    }\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n\nvoid CWE123_Write_What_Where_Condition__fgets_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE123_Write_What_Where_Condition__fgets_03_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE123_Write_What_Where_Condition__fgets_03_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n\n\n/home/daniil/ersp/ersp-test-pipeline/cwes/cwe123/targets/CWE123_Write_What_Where_Condition__connect_socket_01.c\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE123_Write_What_Where_Condition__connect_socket_01.c\nLabel Definition File: CWE123_Write_What_Where_Condition.label.xml\nTemplate File: sources-sink-01.tmpl.c\n*/\n/*\n * @description\n * CWE: 123 Write-What-Where Condition\n * BadSource: connect_socket Overwrite linked list pointers using a connect socket (client side)\n * GoodSource: Don't overwrite linked list pointers\n * Sink:\n *    BadSink : Remove element from list\n * Flow Variant: 01 Baseline\n *\n * */\n\n#include \"std_testcase.h\"\n\ntypedef struct _linkedList\n{\n    struct _linkedList *next;\n    struct _linkedList *prev;\n} linkedList;\n\ntypedef struct _badStruct\n{\n    linkedList list;\n} badStruct;\n\nstatic linkedList *linkedListPrev, *linkedListNext;\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else /* NOT _WIN32 */\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifndef OMITBAD\n\nvoid CWE123_Write_What_Where_Condition__connect_socket_01_bad()\n{\n    badStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* FLAW: overwrite linked list pointers with data */\n            recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    badStruct data;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    /* FIX: don't overwrite linked list pointers */\n    ; /* empty statement needed by some flow variants */\n    /* POTENTIAL FLAW: The following removes 'a' from the list.  Because of the possible overflow this\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\n     * well.  But this is the prototypical \"write-what-where\" at least from\n     * the Windows perspective.\n     *\n     * linkedListPrev = a->list->prev  WHAT\n     * linkedListNext = a->list->next  WHERE\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\n     *                    next/WHAT\"\n     *                    aka \"write-what-where\"\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\n     *                    (because prev is the second field in 'list' hence\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\n     */\n    linkedListPrev = data.list.prev;\n    linkedListNext = data.list.next;\n    linkedListPrev->next = linkedListNext;\n    linkedListNext->prev = linkedListPrev;\n}\n\nvoid CWE123_Write_What_Where_Condition__connect_socket_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE123_Write_What_Where_Condition__connect_socket_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE123_Write_What_Where_Condition__connect_socket_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n\n\n\n--- END OF CODE ---"
    }
]